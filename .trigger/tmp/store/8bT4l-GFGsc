{
  "version": 3,
  "sources": ["../../../../../src/trigger/index.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\r\nimport sharp from \"sharp\";\r\n\r\n// ============================================================\r\n// LLM Execution Task - Uses Google Gemini API\r\n// ============================================================\r\nexport const llmTask = task({\r\n    id: \"llm-execution\",\r\n    retry: { maxAttempts: 2 },\r\n    run: async (payload: {\r\n        prompt: string;\r\n        model?: string;\r\n        images?: string[];\r\n    }) => {\r\n        const modelId = payload.model || \"groq:meta-llama/llama-4-scout-17b-16e-instruct\";\r\n\r\n        // Route to Groq or Gemini\r\n        if (modelId.startsWith(\"groq:\")) {\r\n            const Groq = (await import(\"groq-sdk\")).default;\r\n            const apiKey = process.env.GROQ_API_KEY;\r\n            if (!apiKey) throw new Error(\"GROQ_API_KEY not set\");\r\n\r\n            const groq = new Groq({ apiKey });\r\n            const completion = await groq.chat.completions.create({\r\n                model: modelId.replace(\"groq:\", \"\"),\r\n                messages: [{ role: \"user\", content: payload.prompt }],\r\n                temperature: 0.7,\r\n                max_tokens: 4096,\r\n            });\r\n\r\n            return { text: completion.choices[0]?.message?.content || \"\" };\r\n        } else {\r\n            const { GoogleGenerativeAI } = await import(\"@google/generative-ai\");\r\n            const apiKey = process.env.GOOGLE_AI_API_KEY;\r\n            if (!apiKey) throw new Error(\"GOOGLE_AI_API_KEY not set\");\r\n\r\n            const genAI = new GoogleGenerativeAI(apiKey);\r\n            const model = genAI.getGenerativeModel({ model: modelId });\r\n\r\n            const parts: any[] = [{ text: payload.prompt }];\r\n            if (payload.images?.length) {\r\n                for (const img of payload.images) {\r\n                    const base64Match = img.match(/^data:(.+);base64,(.+)$/);\r\n                    if (base64Match) {\r\n                        parts.push({\r\n                            inlineData: { mimeType: base64Match[1], data: base64Match[2] },\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            const result = await model.generateContent(parts);\r\n            return { text: result.response.text() };\r\n        }\r\n    },\r\n});\r\n\r\n// ============================================================\r\n// Crop Image Task - Uses Sharp for image processing\r\n// ============================================================\r\nexport const cropImageTask = task({\r\n    id: \"crop-image\",\r\n    retry: { maxAttempts: 2 },\r\n    run: async (payload: {\r\n        imageData: string;\r\n        crop: { x: number; y: number; width: number; height: number };\r\n        outputFormat?: string;\r\n    }) => {\r\n        let imageBuffer: Buffer;\r\n\r\n        if (payload.imageData.startsWith(\"data:\")) {\r\n            const base64Data = payload.imageData.split(\",\")[1];\r\n            imageBuffer = Buffer.from(base64Data, \"base64\");\r\n        } else if (\r\n            payload.imageData.startsWith(\"http://\") ||\r\n            payload.imageData.startsWith(\"https://\")\r\n        ) {\r\n            const response = await fetch(payload.imageData);\r\n            const arrayBuffer = await response.arrayBuffer();\r\n            imageBuffer = Buffer.from(arrayBuffer);\r\n        } else {\r\n            imageBuffer = Buffer.from(payload.imageData, \"base64\");\r\n        }\r\n\r\n        const { x, y, width, height } = payload.crop;\r\n        const croppedBuffer = await sharp(imageBuffer)\r\n            .extract({\r\n                left: Math.round(x),\r\n                top: Math.round(y),\r\n                width: Math.round(width),\r\n                height: Math.round(height),\r\n            })\r\n            .toFormat((payload.outputFormat as any) || \"png\")\r\n            .toBuffer();\r\n\r\n        const format = payload.outputFormat || \"png\";\r\n        const mimeType = `image/${format}`;\r\n        const base64 = croppedBuffer.toString(\"base64\");\r\n        return { imageUrl: `data:${mimeType};base64,${base64}` };\r\n    },\r\n});\r\n\r\n// ============================================================\r\n// Extract Frame Task - Stub for video frame extraction\r\n// ============================================================\r\nexport const extractFrameTask = task({\r\n    id: \"extract-frame\",\r\n    retry: { maxAttempts: 1 },\r\n    run: async (payload: {\r\n        videoUrl: string;\r\n        timestamp?: number;\r\n        format?: string;\r\n    }) => {\r\n        // Production deployment options:\r\n        // 1. Deploy to Trigger.dev Cloud with FFmpeg extension\r\n        // 2. Use an external video processing API\r\n        // 3. Install FFmpeg in your deployment environment\r\n        //\r\n        // For now, this returns a helpful error message indicating\r\n        // that FFmpeg is required for frame extraction.\r\n        console.log(\r\n            `[Extract Frame] Received request for video: ${payload.videoUrl?.substring(0, 50)}...`\r\n        );\r\n        console.log(\r\n            `[Extract Frame] Timestamp: ${payload.timestamp || 0}, Format: ${payload.format || \"png\"}`\r\n        );\r\n\r\n        throw new Error(\r\n            \"Extract Frame requires FFmpeg. Deploy to Trigger.dev Cloud with the FFmpeg build extension, \" +\r\n            \"or configure FFmpeg in your deployment environment. \" +\r\n            \"See: https://trigger.dev/docs/guides/frameworks/nextjs\"\r\n        );\r\n    },\r\n});\r\n"],
  "mappings": "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",
  "names": []
}
